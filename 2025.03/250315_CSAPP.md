# TIL - 2025.03.15 (토요일)

## 📝 오늘 배운 것 (Week 1: CSAPP 내용 정리)

### 1.1 정보는 비트와 컨텍스트로 이루어진다

- 소스 프로그램은 0또는 1로 표시되는 비트들의 연속이며 바이트는 8비트 단위로 구성된다.
- 대부분의 컴퓨터 시스템은 텍스트 문자를 아스키(ASCII) 표준을 사용하여 표시한다. 아스키 표준은 각 문자를 바이트 길이의 정수 값으로 나타낸다.
- 오로지 아스키 문자들로 이루어진 파일들은 텍스트 파일이라고 부른다. 다른 모든 파일들은 바이너리 파일이라고 한다.
- 모든 시스템 내부의 정보(디스크 파일, 메모리상의 프로그램, 데이터, 네트워크를 통해 전송되는 데이터)는 비트들로 표시된다. 

### 1.2 프로그램은 다른 프로그램에 의해 다른 형태로 번역된다

- hello.c를 시스템에서 실행시키려면, 각 C 문장들은 다른 프로그램들에 의해 저급 *기계어* 인스트럭션으로 번역되어야 한다. 이 인스트럭션들은 실행가능 *목적 프로그램*이라고 하는 형태로 합쳐져서 바이너리 디스크 파일로 저장된다. 목적프로그램은 *실행가능 목적 파일*이라고도 부른다. 
- *컴파일 시스템*에는 **전처리기, 컴파일러, 어셈블러, 링커** 가 있다.

> - **전처리 단계** : 전처리기(cpp)는 본래의 C 프로그램을 #문자로 시작하는 디렉티브(derective)에 따라 수정한다. 예를 들어 hello.c 파일 첫줄의 `#include<stdio.h>`는 전처리기에게 시스템 헤더파일인 stdio.h를 프로그램 문장에 직접 삽입하라고 지시한다. 그 결과 .i로 끝나는 새로운 C 프로그램이 생성된다.
> - **컴파일 단계** : 컴파일러(cc1)는 텍스트파일 hello.i를 텍스트파일인 hello.s로 번역하며, 이 파일에는 어셈블리어 프로그램이 저장된다. 어셈블리어는 여러 상위순준 언어의 컴파일러들을 위한 공통의 출력언어를 제공하기 때문에 유용하다.
> - **어셈블리 단계** : 다음에는 어셈블러(as)가 hello.s를 기계어 인스트럭션으로 번역하고, 이들을  `재배치가능 목적프로그램`의 형태로 묶어서 hello.o라는 목적파일에 그 결과를 저장한다. 이 파일은 main 함수의 인스트럭션들을 인코딩하기 위한 17바이트를 포함하는 바이너리 파일이다.
> - **링크 단계** : hello 프로그램이 C 컴파일러에서 제공하는 표준 C 라이브러리에 들어있는 printf 함수를 호출하는 것에 주목할 필요가 있다. printf 함수는 이미 컴파일된 별도의 목적파일인 printf.o에 들어 있으며, 이 파일은 hello.o 파일과 어떤 형태로든 결합되어야 한다. 링커 프로그램(id)이 이 통합 작업을 수행한다. 그 결과인 hello 파일은 `실행가능 목적파일`(즉, 실행파일)로 메모리에 적재되어 시스템에 의해 실행된다.

### 1.3 컴파일 시스템이 어떻게 동작하는지 이해하는 것은 중요하다

프로그래머들이 어떻게 컴파일 시스템이 동작하는지 이해해야 하는 중요한 이유가 있다.

- **프로그램 성능 최적화하기** : C 프로그램 작성 시 올바른 판단을 하기 위해서는 기계어 수준 코드에 대한 기본적인 이해를 할 필요가 있다.
- **링크 에러 이해하기** : 가장 당혹스러운 프로그래밍 에러는 링커의 동작과 관련되어 있으며, 큰 규모의 소프트웨어 시스템을 빌드하려는 경우에 더욱 그렇다.
- **보안 약점 (security hole) 피하기** : 안전한 프로그래밍을 배우는 첫 단계는 프로그램 스택에 데이터와 제어 정보가 저장되는 방식 때문에 생겨나는 영향을 이해하는 것이다.

### 1.4 프로세서는 메모리에 저장된 인스트럭션을 읽고 해석한다.

지금까지 hello.c 소스 프로그램은 컴파일 시스템에 의해 hello 라는 실행가능 한 목적파일로 번역되어 디스크에 저장되었다. 이 실행파일을 유닉스 시스템에서 실행하기 위해서 `쉘(shell)`이라는 응용프로그램에 그 이름으 입력한다. 쉘은 커맨드라인 인터프리터로 프롬프트를 출력하고 명령어 라인을 입력 받아 그 명령을 실행한다.

#### 1.4.1 시스템의 하드웨어 조직

hello 프로그램을 실행할 때 무슨 일이 일어나는지 설명하기 위해서는 전형적인 시스템에서의 하드웨어 조직을 이해할 필요가 있다.

**버스(Buses)**
시스템 내를 관통하는 전기적 배선군을 *버스 bus*라고 하며, 컴포넌트들 간에 바이트 정보들을 전송한다. 버스는 일반적으로 *워드 word*라고 하는 고정 크기의 바이트 단위로 데이터를 전송하도록 설계된다. 한개의 워드를 구성하는 바이트 수는 시스템마다 보유하는 기본 시스템 변수다. 4바이트(32비트) 또는 8바이트(64비트) 워드 크기를 갖는다.

**입출력 장치**
입출력 장치(키보드 마우스, 모니터, 데이터 장기 저장을 위한 디스크 드라이브 등)는 시스템과 외부세계와의 연결을 담당한다. 입출력 장치는 입출력 버스와 컨트롤러나 어댑터를 통해 연결된다. 이 두 장치의 차이는 패키징 packaging에 있다. 컨트롤러는 디바이스 자체가 칩셋이거나 시스템의 인쇄기판에 장착된다. 어댑터는 머더보드의 슬롯에 장착되는 카드이다. 

**메인 메모리**
메인 메모리는 프로세서가 프로그램을 실행하는 동안 데이텅와 프로그램을 모두 저장하는 임시 저장장치다. 물리적으로 메인 메모리는 DRAM (Dynamic Random Access memory) 침들로 구성되어 있다. 논리적으로 메모리는 연속적인 바이트들의 배열로 각각 0부터 시작해서 고유의 주소(배열의 인덱스)를 가지고 있다. 일반적으로 한 개의 프로그램을 구성하는 각 기계어 인스트럭션은 다양한 바이트 크기를 갖는다.

**프로세서**
주처리장치(CPU) 또는 간단히 프로세서는 메인 메모리에 저장된 인스트럭션들을 해독(실행)하는 엔진이다. 프로세서의 중심에는 워드 크기의 저장장치(또는 레지스터)인 프로그램 카운터(PC)가 있다. 어느 한순간에 PC는 메인 메모리의 기계어 인스트럭션을 가리킨다. 레지스터 파일은 각각 고유의 이름을 갖는 워드 크기의 레지스터 집합으로 구성되어 있다. ALU는 새 데이터와 주소 값을 계산한다.

- 적재(Load): 메인 메모리에서 레지스터에 한 바이트 또는 워드를 이전 값에 덮어쓰는 방식으로 복사한다.
- 저장(Store): 레지스터에서 메인 메모리로 한 바이트 또는 워드를 이전 값을 덮어쓰는 방식으로 복사한다.
- 작업(Operate): 두 레지스터의 값을 ALU로 복사하고 두 개의 워드로 수식연산을 수행한 뒤, 결과를 덮어쓰기 방식으로 레지스터에 저장한다.
- 점프(Jump): 인스트럭션 자신으로부터 한개의 워드를 추출하고 이것을 PC에 덮어쓰기 방식으로 복사한다.

#### 1.4.2 hello 프로그램의 실행

처음에 쉘 프로그램은 자신의 인스트럭션을 실행하면서 사용자가 명령을 입력하기를 기다린다. ".\hello"를 입력하면 쉘 프로그램은 각각의 문자를 레지스터에 읽어 들인 후 메모리에 저장한다.

키보드에서 엔터키를 누르면 쉘은 명령 입력을 끝마쳤다는 것을 알게 된다. 그러면 쉘은 파일 내의 코드와 데이터를 복사하는 일련의 인스트럭션을 실행하여 실행파일 hello를 디스크에서 메인 메모리로 로딩한다. 데이터 부분은 최종적으로 출력되는 문자 스트링인 "hello, world\n"을 포함한다. 직접 메모리 접근이라고 알려진 기법을 이용해서 데이터는 프로세서를 거치지 않고 디스크에서 메인 메모리로 직접 이동한다.

일단 hello 목적파일의 코드와 데이터가 메모리에 적재된 후, 프로세서는 hello 프로그램의 main 루틴의 기계어 인스트럭션을 실행하기 시작한다. 이 인스트럭션들은 "hello. word\n" 스트링을 메모리로부터 레지스터 파일로 복사하고, 디스플레이 장치로 전송하여 화면에 글자들이 표시된다.

## 💡 문제 해결

> 오늘 해결한 문제나 어려웠던 부분을 기록합니다.

## 🔍 더 알아볼 것

- [ ] 항목 1
- [ ] 항목 2

## 🧐 느낀 점

오늘 배운 내용에 대한 개인적인 생각이나 느낌을 기록합니다.

## 📚 참고 자료

- [제목](링크)
