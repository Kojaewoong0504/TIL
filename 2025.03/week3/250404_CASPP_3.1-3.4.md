# TIL - 2025.04.05 (토요일)

## 📝 오늘 배운 것 CSAPP 3.2 ~ 3.4 정리

## 🫵 초등학생도 이해하는 CSAPP

🧠 우리가 컴퓨터에게 말하는 방법
컴퓨터는 사람처럼 말을 이해하지 못해요. 그래서 우리가 C 언어처럼 사람이 이해하기 좋은 언어로 프로그램을 짜면, 이걸 컴퓨터가 알아들을 수 있도록 바꿔줘야 해요. 이 과정을 컴파일이라고 해요.

📦 컴파일은 포장을 여러 번 하는 것과 같아요

1. 우리가 만든 C 코드는 먼저 특별한 도구(gcc 컴파일러)가 받아서, 좀 더 단순한 글씨로 바꿔요. 이걸 어셈블리 코드라고 해요. 이건 사람이 읽을 수 있지만 컴퓨터는 아직 바로 이해하지 못해요.

2. 그다음에 어셈블리 코드는 숫자로만 이루어진 코드, 즉 기계어로 바뀌어요. 이걸 오브젝트 코드라고 해요.

3. 마지막으로, 이 오브젝트 코드를 모아서 진짜 컴퓨터가 바로 실행할 수 있는 실행 파일을 만들어요.

즉, 마치 선물 포장을 단계별로 하는 것처럼, 우리가 쓴 코드도 여러 단계를 거쳐서 컴퓨터가 이해할 수 있는 형태가 되는 거예요.

---

🤖 기계어는 컴퓨터가 쓰는 언어예요
컴퓨터는 기계어라는 아주 단순한 명령어들을 사용해요. 이건 말하자면 “더하기 해!”, “저기 있는 걸 가져와!” 같은 아주 단순한 말이에요. 그리고 이 명령어들을 한 줄씩 차례대로 읽어요.

컴퓨터 안의 기억 공간
컴퓨터는 메모리라는 곳에 데이터를 저장해요. 근데 우리가 보기에는 커다란 종이처럼 보이지만, 사실은 아주 작은 칸칸들이 있고, 그걸 주소라는 숫자로 하나하나 구분해요. 이걸 가상 주소라고 불러요.

---

🧩 기계어가 뭔지 궁금하다면?
기계어는 너무 복잡하고 숫자 덩어리라서 읽기 어려워요. 그래서 사람은 어셈블리 코드를 봐요. 어셈블리 코드는 기계어랑 거의 똑같지만, 사람이 읽기 쉽게 글자로 표현된 버전이에요.

---

🎮 컴퓨터는 이렇게 작동해요

- 프로그램 카운터(PC): 다음에 어떤 명령을 실행할지 알려주는 위치 표시기예요.

- 레지스터: 숫자나 주소 같은 걸 저장해두는 특별한 장소예요. 총 16개가 있어요.

- 조건 코드: 방금 했던 계산 결과가 0인지, 음수인지 등을 알려줘요.

- 벡터 레지스터: 여러 숫자를 한꺼번에 담아두는 큰 상자예요.

---

🧩 왜 우리가 보는 코드랑 다르게 생겼나요?
우리가 짠 C 언어 코드랑 기계어는 너무 다르게 생겼어요. 우리가 보는 C 코드는 사람이 보기 쉽게 글자로 되어 있어요. 하지만 기계어는 숫자와 0, 1로 이루어져 있어서 사람이 보기에는 정말 복잡하고 어렵게 보여요.

그래서 우리는 어셈블리 코드라는 걸 사용해요. 이건 기계어랑 거의 똑같지만, 사람이 이해할 수 있게 단어(명령어)로 표현된 거예요.

예시:

- C 코드: x = y + z;

- 어셈블리 코드: mov eax, y → add eax, z

- 기계어: 10111000 00001100 ... (숫자 덩어리)

---

📏 64비트 컴퓨터란?
책에서는 x86-64라는 64비트 컴퓨터를 예로 들고 있어요. 여기서 64비트는 한 번에 다룰 수 있는 정보의 크기를 뜻해요. 즉, 더 크고 빠르게 계산할 수 있다는 뜻이야!

💡 예제: multstore 함수
C 코드

```c
long mult2(long, long);

void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
```

이 코드는 x와 y라는 두 숫자를 곱해서(mult2라는 함수로 곱함), 그 결과를 dest라는 장소에 저장하는 함수야. 마치 이런 거지:

> “두 숫자를 곱해서, 결과를 보관함에 넣어라!”

---

🔧 어셈블리 코드 버전 (기계가 이해하는 언어)
이걸 컴퓨터가 이해하는 아주 간단한 지시문들로 바꾸면 이렇게 돼:

1. 상자 하나 꺼내기 – pushq %rbx
    → 나중에 쓰기 위해 기억 장소 하나 확보!

2. 결과를 저장할 장소 기억해두기 – movq %rdx, %rbx
    → “아! 결과는 여기다 저장해야지” 하고 기억해둠.

3. 곱셈 함수 부르기 – call mult2
    → “곱하기 해줘!”라고 요청.

4. 곱셈 결과 저장하기 – movq %rax, (%rbx)
    → 받은 결과를 아까 기억해둔 장소에 저장.

5. 기억해둔 상자 다시 제자리 – popq %rbx
    → “정리 끝!”

6. 끝났어! 돌아가자 – ret
    → 함수 끝났다는 뜻이야.

```asm
pushq   %rbx
movq    %rdx, %rbx
call    mult2
movq    %rax, (%rbx)
popq    %rbx
ret
```

이 코드는 multstore라는 함수의 속을 어셈블리 언어로 옮긴 거야. 이제 한 줄씩, 마치 로봇에게 명령하듯이 설명해볼게!

### 🧩 1. pushq %rbx

🧠 뜻: “RBX라는 이름의 기억 상자에 있던 값을 잠깐 보관해둘게!”

📦 왜 하냐면: 우리는 곧 RBX를 다른 걸로 쓸 거라서, 원래 들어 있던 걸 저장해둬야 나중에 다시 꺼낼 수 있어. 마치 게임에서 아이템을 다른 상자에 잠깐 넣어두는 것처럼!

### 🧩 2. movq %rdx, %rbx

🧠 뜻: “RDX에 있던 내용을 RBX에 복사해!”

📦 예를 들어: RDX에는 우리가 계산 결과를 저장하고 싶은 장소 주소가 들어 있어. 이걸 RBX로 옮겨 놓는 거야. 왜냐하면 곧 RDX는 다른 데 쓰일 수도 있으니까!

### 🧩 3. call mult2

🧠 뜻: “mult2라는 계산기 함수를 불러!”

🧮 무슨 일? x와 y를 곱해주는 계산기 함수 mult2를 호출해. 계산이 끝나면 그 결과는 RAX라는 상자에 담겨 있어.

### 🧩 4. movq %rax, (%rbx)

🧠 뜻: “RAX에 있는 계산 결과를, 아까 기억해둔 장소(RBX)에 넣어!”

📬 쉽게 말하면: “곱한 값을 우리가 저장하고 싶었던 주소에 써줘!”

### 🧩 5. popq %rbx

🧠 뜻: “아까 잠깐 보관해둔 RBX 원래 내용 다시 가져와!”

🔁 왜? 함수가 끝났을 때는, 함수가 시작되기 전처럼 기억장치를 원상태로 되돌려놔야 해. 마치 방 청소 후 원래 자리로 물건을 돌려놓는 것처럼!

### 🧩 6. ret

🧠 뜻: “이 함수는 다 끝났어! 원래 있던 곳(함수 호출한 곳)으로 돌아가!”

🏁 이게 끝! 계산도 했고 결과도 저장했으니, 이제 할 일은 끝났다는 뜻이야.

---

🎯 전체 이야기 정리

1. 먼저 중요한 정보는 잠깐 따로 보관하고,

2. 어디에 저장할지 기억하고,

3. 계산을 부탁하고,

4. 그 결과를 정해진 장소에 놓고,

5. 보관했던 정보 다시 가져오고,

6. 함수 끝났다고 알리는 것!

어셈블리 언어는 마치 로봇에게 "한 걸음 왼쪽", "손 들기", "그릇 집기" 이런 식으로 아주아주 세세하게 시키는 거야. 우리가 편하게 쓰는 C 언어도 결국엔 이런 자세한 명령으로 바뀌어서 실행되는 거고!

---

## 💡 레지스터란 뭘까?

우선 컴퓨터 안에는 **"레지스터(register)"**라는 특별한 작은 상자들이 있어.
이 상자들은 아주 빠르게 작동하는 기억 장소야. 숫자나 정보를 잠깐 저장할 수 있어.

우리가 흔히 "변수"를 쓰듯이, 컴퓨터는 이 "레지스터"에 값을 담고 꺼내면서 계산을 해.

## 🧠 그럼 rax, rbx는 뭐야?

레지스터들은 각각 이름이 있어! 사람 이름처럼. 예를 들어:

- rax = 계산 결과를 넣는 레지스터 (a = accumulator = 계산기 느낌!)

- rbx = 보조 역할을 하는 레지스터 (b = base = 기반 느낌)

- rcx = 카운터 역할 (c = counter = 세는 용도)

- rdx = 데이터 전송용 (d = data)

이런 식으로 rax, rbx, rcx, rdx 등 이름 붙은 상자들이 있어. 컴퓨터는 이걸 써서 빠르게 계산해.

    📦 예시: "컴퓨터야, 숫자 3을 rax에 넣어줘!"
    📦 그리고 "이제 rbx에 있는 숫자랑 더해줘!"

## 🧬 왜 r이 붙어 있어?

좋은 관찰이야!

- 아주 옛날에는 16비트 CPU에서는 그냥 ax, bx 이렇게 썼어.

- 그 다음 32비트 시대로 넘어오면서 eax, ebx처럼 이름이 길어졌지.

- 지금은 64비트 시대! 그래서 앞에 r을 붙여서 rax, rbx라고 불러!

📏 숫자를 더 많이 저장하려고 이름도 길어진 거야. 마치 작은 상자에서 큰 상자로 바꾼 거지!

---

### 🧩 rax는 왜 없던 게 나왔어?

좋은 눈썰미야! 아까 우리가 C로 작성한 코드에서는 rax라는 이름을 직접 쓰지 않았어.
하지만! 컴퓨터는 mult2(x, y) 결과를 계산한 다음, 그 결과를 자동으로 rax에 넣어둬.

📦 마치 “계산기 결과는 항상 이 그릇(rax)에 넣어줄게!”라고 약속한 것처럼!

그래서 어셈블리에서는 rax를 꺼내서 저장 장소(rbx)로 옮긴 거야:

```asm
movq %rax, (%rbx)
```

---

🔁 정리하면?

|이름	|의미|	언제 쓰는지|
|-|-|-|
|rax|	계산 결과 상자|	함수가 계산한 값을 담음|
|rbx|	보조 상자|	값 저장할 장소 주소를 담음|
|rdx|	데이터 상자|	함수에 전달할 주소 같은 걸 넣어줌|

## 📄 전체 C 코드 예시

```c
#include <stdio.h>

void multstore(long, long, long *);

int main() {
    long d;
    multstore(2, 3, &d);
    printf("2 * 3 --> %ld\n", d);
    return 0;
}

long mult2(long a, long b) {
    long s = a * b;
    return s;
}
```

## 🔍 하나씩 뜯어보자!

### 🧩 main 함수

```C
int main() {
    long d;
    multstore(2, 3, &d);
    printf("2 * 3 --> %ld\n", d);
    return 0;
}
```

이건 프로그램의 시작점이야! 컴퓨터는 여기서부터 실행을 시작해.

- long d;

    → 큰 숫자를 담을 수 있는 상자(d)를 하나 만들었어!

- multstore(2, 3, &d);

    → “2와 3을 곱해서 결과를 d에 저장해줘!” 라고 multstore 함수에게 부탁하는 거야.

- printf("2 * 3 --> %ld\n", d);

    → 계산된 값을 화면에 보여주는 부분이야. 예를 들면 2 * 3 --> 6 이렇게!

---

### 🧩 mult2 함수

```c
long mult2(long a, long b) {
    long s = a * b;
    return s;
}
```

이 함수는 진짜로 “곱하기”를 하는 함수야.

- a * b → 숫자 두 개를 곱해!

- return s; → 곱한 결과를 돌려줘!

이게 바로 multstore 함수에서 호출해서 사용하던 계산기 역할을 하는 부분이야.

---

🔗 연결된 흐름 정리

1. main()에서 multstore(2, 3, &d)를 호출해

2. multstore()가 mult2(2, 3)을 불러서 계산

3. mult2()가 2 * 3 = 6을 계산해서 알려줘

4. multstore()는 그 결과(6)를 d라는 상자에 저장해

5. main()이 d를 출력해 → “2 * 3 --> 6”

---

### 🧠 레지스터와 메모리의 역할

|이름	|역할	|예시 값|
|-|-|-|
|%rdi|	첫 번째 인자|	2|
|%rsi|	두 번째 인자|	3|
|%rdx|	세 번째 인자 (저장할 주소)|	d의 주소|
|%rbx|	임시 저장용 레지스터|	d 주소 복사|
|%rax|	함수 결과 리턴 값|	6|

---

## 📦 그림으로 본 함수 흐름

### 1. main 함수 실행

```
main:
    long d;

    [%rdi] = 2
    [%rsi] = 3
    [%rdx] = &d  (예: 0x7ffc1234)

    call multstore

메모리:
0x7ffc1234 ── [ ? ]   ← d의 주소, 아직 값 없음
```

### 2. multstore 함수 시작

```
mov %rdx, %rbx  ; d의 주소를 rbx에 복사
call mult2      ; 2와 3을 곱하러 감!

레지스터:
%rdi = 2
%rsi = 3
%rbx = 0x7ffc1234
```

### 3. mult2 함수 실행

```
imul %rdi, %rsi ; 2 * 3 → %rsi = 6
mov %rsi, %rax  ; 결과를 %rax에 저장
ret             ; 결과 반환

레지스터:
%rax = 6
```

### 4. 다시 multstore

```
mov %rax, (%rbx) ; 결과 6을 메모리 주소 0x7ffc1234에 저장

메모리:
0x7ffc1234 ── [ 6 ]   ← 이제 d = 6!
```

### 5. 다시 main

```c
printf("2 * 3 --> %ld\n", d);
```

🖨️ 출력 결과: 2 * 3 --> 6

## 3.4 정보 접근하기 (Accessing Information)

### 🧠 주제 한 줄 요약

컴퓨터 안에서 값을 꺼내오고, 어디에 저장할지를 정하는 방법을 배우는 부분이야.

### 🧩 1. 레지스터란 무엇일까?

컴퓨터 속에는 레지스터라는 아주 빠른 상자들이 있어.
이 상자들은 숫자나 주소 같은 값을 잠깐 보관해.

레지스터 이름들

- %rax, %rbx, %rcx, %rdx …

- %r8, %r9, … %r15

- %rsp: 스택의 끝을 가리키는 특수한 레지스터!

예를 들어, %rax는 계산 결과를 담는 상자,
%rsp는 스택 위에 뭐가 올라갔는지 알려주는 상자야.

---

### 🧩 2. 값은 어디에 있을 수 있을까?

컴퓨터에서 다루는 값은 3곳에 있을 수 있어:

|종류|	설명|	예시|
|-|-|-|
|Immediate (즉시 값)|	그냥 숫자 자체|	$3, $0x10|
|Register (레지스터 값)|	레지스터 안에 있는 값|	%rax, %rbx|
|Memory (메모리 주소)|	주소로 찾아가는 값|	(%rax), 8(%rbx)|

---

### 🧩 3. 메모리 주소를 계산하는 방법 (어드레싱)

주소를 계산하는 다양한 방법들이 있어. 예를 들어:

- (%rax) : rax가 가리키는 주소에 있는 값

- (%rax) : rax 주소 + 8에 있는 값

- (%rax, %rdx, 4) : rax + rdx*4 위치에 있는 값

이건 마치:

"아빠 서랍 안에서 왼쪽으로 4칸 더 간 곳에 있는 장난감 가져와!"
이런 식으로 주소를 계산해서 값을 꺼내는 거야.

---

### 🧩 4. mov 명령어로 값 옮기기

컴퓨터는 mov 명령어를 써서 값을 옮겨. 예를 들어:

```asm
movq %rax, (%rbx)
```

이건 무슨 뜻이냐면:

“rax 상자에 있는 값을, rbx가 가리키는 주소에 넣어줘!”

---

### 🎯 진짜 중요한 핵심 요약!

- 컴퓨터는 값을 빠르게 쓰고 읽기 위해 레지스터를 써.

- 값을 직접 넣거나, 레지스터에 저장하거나, 메모리에서 불러올 수 있어.

- 메모리 주소는 계산해서 만들 수 있어! (주소 + 숫자, 주소 + 인덱스 * 크기 등)

- mov 같은 명령어로 값을 이리저리 옮겨!

## 3.4.1 피연산자 지정자(Operand Specifiers)

### 🎯 이 절에서 다루는 이야기

어셈블리 명령어에서 “어디서 값을 가져오고”, “어디에 저장할지”를 정하는 다양한 방법을 배우는 거야!

---

### 🧩 피연산자(Operand)란?

피연산자는 계산에 필요한 값이야.
컴퓨터한테 "이걸 가지고 계산해!" 라고 말할 때 쓰는 대상이지.

```asm
movq %rax, (%rbx)
```

이건 rax에 있는 값을 rbx가 가리키는 주소에 저장하라는 뜻인데,
여기서 %rax와 (%rbx)가 피연산자야!

---

### 🔤 피연산자 종류 (쉽게 말해!)

|종류	|예시|	뜻|
|-|-|-|
|즉시 값 (Immediate)|	$10|	그냥 숫자 10|
|레지스터 값 (Register)|	%rax|	rax라는 이름의 상자에 있는 값|
|메모리 값 (Memory)|	(%rax)	|rax가 가리키는 주소에 있는 값|

---

### 🧠 메모리 주소 계산 방식 (어려운 말: 어드레싱 모드)

컴퓨터는 주소도 계산할 수 있어! 아래처럼 다양한 방식이 있어:

|형태|	뜻 (쉽게 설명)|
|-|-|
|Imm|	주소 그대로 사용 (예: 0x100)|
|(ra)|	ra라는 레지스터가 가리키는 주소|
|Imm(rb)|	rb가 가리키는 주소 + Imm만큼 더한 곳|
|(rb, ri)|	rb와 ri의 값을 더한 주소|
|Imm(rb, ri)|	주소 = Imm + rb + ri|
|(, ri, s)|	주소 = ri * s|
|Imm(, ri, s)|	주소 = Imm + ri * s|
|(rb, ri, s)|	주소 = rb + ri * s|
|Imm(rb, ri, s)|	주소 = Imm + rb + ri * s|

예: 8(%rax, %rdx, 4)
    → 주소 = 8 + %rax + 4 * %rdx

이건 마치:

"책상 서랍에서 왼쪽으로 8칸 + 다리 번호 * 4만큼 더 간 위치에서 장난감 찾아와!"

---

### 🧩 왜 이렇게 복잡하게 주소를 계산해?

이런 방식은 배열이나 구조체 안의 값을 꺼낼 때 아주 유용해!

예를 들어

```c
int arr[5];
int x = arr[3];
```

→ 이건 어셈블리에서 대충 이렇게 될 수 있어:

```asm
movl 12(%rdi), %eax
```

왜냐면 3번째 요소는 3 * 4 = 12 바이트 뒤에 있으니까!

## 3.4.2 데이터 이동 명령어(Data Movement Instructions)

### 🎯 이 절의 핵심

컴퓨터가 값을 여기서 저기로 옮기는 방법에 대해 설명하는 부분이야!

---

### 📦 mov 명령어란?

mov는 어셈블리어에서 가장 많이 쓰이는 "값 복사" 명령어야.

```asm
mov 소스, 목적지
```

예:

```asm
mov %rax, %rbx  ; rax에 있던 값을 rbx로 복사해!
```

이건 마치:

“장난감 상자 A에 있던 블록을 상자 B로 복사해!”

---

### 🧩 mov 명령어의 종류

|명령어|	설명|	몇 바이트 이동할까?|
|-|-|-|
|movb|	바이트(byte) 이동	|1 바이트|
|movw|	워드(word) 이동|	2 바이트|
|movl|	더블워드 이동|	4 바이트|
|movq|	쿼드워드 이동|	8 바이트|

> 이름의 끝이 b, w, l, q로 끝나면 이동할 크기를 말하는 거야!

---

### 🧠 다섯 가지 조합 예시

어셈블리는 어디서 → 어디로 값을 옮기는지에 따라 여러 형태가 있어:

1. 즉시값 → 레지스터

```asm
movl $0x4050, %eax
```

→ 숫자 0x4050을 %eax에 넣어줘!
2. 레지스터 → 레지스터

```asm
movw %bp, %sp
```

→ %bp의 값을 %sp로 옮겨줘
3. 메모리 → 레지스터

```asm
movb (%rdi,%rcx), %al
```

→ 주소 계산해서 그 주소의 값 한 바이트를 %al로!
4. 즉시값 → 메모리

```asm
movb $-17, (%esp)
```

→ 메모리에 바로 -17을 써넣어!
5. 레지스터 → 메모리

```asm
movq %rax, -12(%rbp)
```

→ rax에 있는 8바이트 값을 메모리 주소에 써넣어

---

### ⚠️ 주의할 점!

x86-64에서는 메모리에서 메모리로 직접 이동은 안 돼!

예를 들어,

```asm
movq (%rax), (%rbx)  ; ❌ 안 됨!
```

이런 건 안 되고, 이렇게 두 단계로 나눠야 해:

```asm
movq (%rax), %rcx
movq %rcx, (%rbx)
```

---

### 🧪 movl만의 특별한 점!

```asm
movl %eax, %ebx
```

이건 단순히 4바이트만 복사하는 게 아니라, 상위 4바이트를 0으로 지워!

→ 즉, %rax의 전체 8바이트 중, 앞 4바이트는 0으로!

이건 movl만 특별히 그런 거야~

---

✅ 요약

- mov는 컴퓨터에서 값을 복사하는 명령어!

- 크기에 따라 movb, movw, movl, movq로 나뉘어

- 소스와 목적지의 조합도 다양하게!

- movl만은 상위 4바이트를 0으로 초기화하는 특이한 동작을 해

---

## 🧩 상황 설정: 상자 크기가 다를 때

예를 들어볼게!

- 작은 상자: 1바이트짜리 (movb)

- 큰 상자: 4바이트짜리 (movl)

작은 값이 들어 있는 상자를 큰 상자로 옮기면, 나머지 공간을 어떻게 채울까?
그걸 정해주는 게 바로 movz와 movs야!

---

### 🌟 movz = "빈 공간을 0으로 채워!"

예:

```asm
movzbl %al, %ebx
```

뜻:

- %al은 1바이트 상자야 (예: 값이 11110000)

- 이걸 %ebx 4바이트 상자에 옮기는데,

- 나머지 3바이트는 전부 0으로 채워!

```peri
%ebx = 00000000 00000000 00000000 11110000
```

✔️ Z = zero-fill = 0으로 채우기!

---

### 🌟 movs = "빈 공간을 부호(sign)로 채워!"

예:

```asm
movsbl %al, %ebx
```

- %al에 있는 1바이트 값의 가장 앞 비트(부호 비트)를 보고,

- 그 값이 음수이면 나머지 공간을 1로 채워,

- 양수면 0으로 채워!

예: %al = 11110000 (맨 앞 비트가 1이니까 음수)

```peri
%ebx = 11111111 11111111 11111111 11110000
```

✔️ S = sign-extend = 부호로 확장!

---

### 🎯 요약 비교표

|명령어|	뜻|	빈 공간에 뭐가 들어갈까?|
|-|-|-|
|movz	|zero-extend|	항상 0|
|movs	|sign-extend	|부호에 따라 0 또는 1|

- movz는 작은 숫자를 큰 종이에 옮길 때 **빈 칸을 하얀색(0)**으로 칠하는 거야.

- movs는 숫자가 음수면 검정색(1), **양수면 하얀색(0)**으로 칠하는 거야.