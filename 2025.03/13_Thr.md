# TIL - 2025.03.13 (목요일)

## 📝 오늘 배운 것

### JWT를 안전하게 저장하기
#### 액세스 토큰 저장 방식
> 액세스 토큰의 경우 함수 스코프 내 로컬 변수에 저장한다. 이는 다음과 같은 이유가 있다.
> 1. 함수 스코프 내 로컬 변수는 해당 함수 실행 중에만 존재하므포 XSS공격에 노출될 가능성이 낮다.
> 2. 로컬 스토리지나 세션 스토리지와 달리 JavaScript를 통한 접근이 제한된다.
> 3. 메모리에만 존재하므로 브라우저 개발자 도구를 통해서도 쉽게 접근할 수 있다.

함수 스코프 내 로컬 변수는 다음을 의미한다.
1. 변수의 생명주기 : 함수가 실행될 때 생성되고 함수 실행이 종료되면 메모리에서 제거된다.
2. 접근 범위 제한 :해당 변수는 선언된 함수 내부에서만 접근 가능하며, 함수 외부에서는 접근할 수 없다.
3. 클로저를 통한 활용 : 실제로는 클로저(closure)패턴을 사용하여 함수 실행이 끝나도 내부 상태를 유지하면서 외부에서 직접 접근은 불가능하게 만든다.
``` javascript 
// 인증 관련 모듈
const authModule = (function() {
  // 함수 스코프 내 로컬 변수로 액세스 토큰 저장
  let accessToken = null;
  
  return {
    // 토큰 설정 함수
    setToken: function(token) {
      accessToken = token; // 로컬 변수에 저장
    },
    
    // API 요청 시 토큰 사용
    makeAuthenticatedRequest: function(url, options) {
      // 토큰을 사용하지만 외부에서는 직접 접근 불가
      return fetch(url, {
        ...options,
        headers: {
          ...options?.headers,
          'Authorization': `Bearer ${accessToken}`
        }
      });
    },
    
    // 로그아웃 시 토큰 제거
    clearToken: function() {
      accessToken = null;
    }
  };
})();

```
이 방식의 장점은 accessToken 변수가 IIFE(즉시 실행 함수 표현식)내부에 캡슐화되어 있어 전역 스코프에서 접근할 수 없고,
XSS 공격으로부터 상대적으로 안전하다는 점이다. 토큰은 오직 정의된 메서드를 통해서만 사용될 수 있으며, 브라우저의 개발자 도구나 JavaScript를
통해 직접 접근하는 것이 불가능하다.
> 클로저는 무엇인가?
> 클로저(Closure)는 javascript의 중요한 개념으로, 함수와 그 함수가 선언된 어휘적 환경(Lexical Environment)의 조합이다.
> 함수가 자신이 생성될 당시의 외부 변수를 기억하고 접근할 수 있는 특성을 말한다.
> 1. 함수 내부에서 외부 변수에 접근 : 함수는 자신이 선언된 환경의 변수에 접근할 수 있다.
> 2. 함수가 반환된 후에도 외부 변수 유지 : 함수가 생성된 환경의 변수는 함수가 반환된 후에도 계속 유지된다.
> 3. 데이터 은닉과 캡슐화 : 외부에서 직접 접근할 수 없는 private 변수를 만들 수 있다.
더 쉽게 이해한다면 JavaScript 함수 내부에 변수를 정의하고 return문을 작성하고 그 return문 내부에 객체를 만들고 그 안에 함수를 정의하는 방법 같다.
이는 javascript의 함수와 스코프 특성을 활용한 프로그래밍 패턴이다. 핵심구조는 다음과 같다.
1. 외부 함수를 정의한다.
2. 외부 함수 내부에 지역 변수를 선언한다.
3. 외부 함수 내부에서 내부 함수를 정의하고, 이 내부 함수가 외부 함수의 지역 변수를 참조한다.
4. 외부 함수는 내부 함수를 반환한다.(객체 내부에 함수를 담아 반환하는 경우가 많다.)

#### 리프레시 토큰 저장 방식
> 리프레시 토큰을 쿠키에 저장한다.하지만 단순히 쿠키에 저장하는 방식은 위험하니 추가적인 설정이 필요하다.
> 1. HttpOnly 플래그 : JavaScript를 통한 접근 방지
> 2. Secure 플래그 : HTTPS 통신에서만 전송
> 3. SameSite=Strict 또는 SameSit=Lax : CSRF 공격 방지
> 4. 가능하면 Path 속성 제한
> 이 외에도 추가적인 CSRF 토큰 검증 메커니즘을 구현하는 것이 좋다.


### JWT 토큰의 보안
#### 리프레시 토큰의 사용
액세스 토큰의 만료기간을 짧게 잡고 만료주기로 인한 빈번한 로그인 요청이 발생하지 않도록 리프레시 토큰을 활용한다. 또한 로그아웃과 같은 기능에서 기존에 발급된 토큰을 사용할 수 없도록 해야 한다. 이미 발급된 토큰을 만료시킬 방법이 없기 때문에 엑세스 토큰의 경우 블랙기스트에 추가해 관리하고, 리프레시 토큰의 경우 화이트리스트 방식을 사용해서 DB에 존재하는 토큰만 사용할 수 있도록 하고 로그아웃 시 DB에서토큰을 삭세하는 방법을 활용한다. 

#### 블랙리스트 (액세스 토큰용)
블랙리스트는 더 이상 유효하지 않은(취소된) 토큰의 목록이다. 액세스 토큰에 블랙리스트 접근법을 사용하는 이유는 다음과 같다.
- 액세스 토큰은 수명이 짧기 때문에 블랙리스트의 크기가 제한적
- 대부분의 액세스 토큰은 자연스럽게 만료되므로 모든 토큰을 추적할 필요 없다.
- 로그아웃이나 보안 침해 시에만 블랙리스트에 추가

#### 화이트리스트 (리프레시 토큰용)
화이트리스트는 현재 유효한 토큰의 목록이다. 리프레시 토큰에 화이트리스트 접근법을 사용하는 이유는 다음과 같다.
- 리프레시 토큰은 수명이 길어 더 엄격한 관리가 필요하다.
- 사용자당 리프레시 토큰 수가 제한적이므로 관리 가능한다.
- 로그아웃 시 간단히 DB에서 삭제하여 무효화 가능하다.

하지만 액세스 토큰과 리프레시 토큰을 서버에 기록하고 관리하는 것은 JWT의 장점인 무상태성을 침해한다.

그래서 대안으로 RTR(Refresh Token Rotation) 패턴이 효과적일 수 있다.
#### RTR(Refresh Token Rotation)패턴의 핵심
1. 일회성 리프레시 토큰 : 리프레시 토큰은 단 한 번만 사용할 수 있으며, 사용 시 새로운 액세스 토큰과 함꼐 새로운 리프레스 토큰이 발급된다.
2. 토큰 계보 추적 : 서버는 발급된 리프레시 토큰의 계보를 추적하여 토큰 재사용 감지 시 해당 계보의 모든 토큰을 무효화 한다.
3. 자동 무효화 : 리프레시 토큰이 사용되면 이전 액세스 토크과 리프레시 토큰은 자동으로 무효화된다.

#### RTR의 장점
1. 액세스 토큰 블랙리스트 불필요 : 엑세스 토큰의 수명이 짧고, 리프레시 토큰 사용 시 이전 액세스 토큰이 자동으로 무효화되므로 블랙리스트가 필요 없다.
2. 무상태성 유지 : 엑세스 토큰은 여전히 무상태로 유지되어 JWT의 장점을 살릴 수 있다.
3. 토큰 탈취 감지 : 리프레시 토큰이 재사용되면 토큰 탈취를 감지하고 해당 사용자의 모든 세션을 무효화 할 수 있다.

RTR을 적용하기 위해 토큰 계보 추적 구현과 토큰 재사용 감지 및 계보 무효화, 자동 무효화를 구현해야 한다.
 
## 💡 문제 해결

> JWT토큰을 이용하는 것에서 그치지 않고 클로저, 쿠키를 사용한 토큰 저장과 토큰의 보안을 위한 RTR방식에 대한 내용

## 🔍 더 알아볼 것

- [ ] RTR 구현 사례 
- [ ] 모바일 앱에서의 활용 방법

## 🧐 느낀 점

JWT를 최초로 접한지 3년이 가까워 졌지만 아직도 JWT를 잘 사용할 수 있는 방법을 자세히 모른다는 것이 부끄러웠고 지금도 이 방법이 정말 좋은 방법인지 알 수 없다는 두려움을 가지고 있지만 오늘을 기점으로 매일 더 발전해야겠다.

## 📚 참고 자료

- [JWT 어디에 저장해야 할까] https://bbogle2.tistory.com/entry/JWT-%EC%96%B4%EB%94%94%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C